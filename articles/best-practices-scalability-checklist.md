<properties
   pageTitle="Lista de verificação de escalabilidade | Microsoft Azure"
   description="Orientação de lista de verificação de escalabilidade para questões de design para Autoscaling do Azure."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="scalability-checklist"></a>Lista de verificação de escalabilidade

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>Design de serviço
- **Partição a carga de trabalho**. Partes do processo de ser decomposable e discreto de design. Minimize o tamanho de cada parte, enquanto segue as regras de costume de separação de preocupações e o princípio da responsabilidade única. Isso permite que os componentes sejam distribuídas de maneira que maximiza o uso de cada unidade de computação (como um servidor de banco de dados ou função). Ele também torna mais fácil dimensionar o aplicativo adicionando instâncias de recursos específicos. Para obter mais informações, consulte [Calcular partição orientação](https://msdn.microsoft.com/library/dn589773.aspx).
- **Design de dimensionamento**. Dimensionamento permite que aplicativos reagir a carga variável aumentando e diminuindo o número de instâncias de funções, filas e outros serviços usarem. No entanto, o aplicativo deve ser projetado com isso em mente. Por exemplo, o aplicativo e os serviços que ele usa devem ser estados, para permitir que as solicitações para ser roteados para qualquer instância. Isso também impede a adição ou remoção de ocorrências específicas afetar negativamente os usuários atuais. Você também deve implementar configuração ou a detecção automática de instâncias conforme elas são adicionadas e removidas, para que o código no aplicativo pode executar o roteamento necessárias. Por exemplo, um aplicativo web pode usar um conjunto de filas em uma abordagem de alternada para rotear solicitações para serviços de plano de fundo em execução em funções de trabalho. O aplicativo web deve ser capaz de detectar alterações no número de filas, para rotear solicitações e saldo a carga no aplicativo com êxito.
- **Escala como uma unidade**. Planejar recursos adicionais acomodar o crescimento. Para cada recurso, sabe superior dimensionamento limites e use fragmentação ou Decomposição ir além esses limites. Determine as unidades de escala para o sistema em termos bem definidos conjuntos de recursos. Isso tornará aplicando operações de fora de escala mais fácil e menos propensa a impacto negativo no aplicativo por meio de limitações impostas por falta de recursos na parte geral do sistema. Por exemplo, adicionando x número de funções da web e trabalhador pode exigir y número de filas adicionais e z das contas de armazenamento para lidar com a carga de trabalho adicional gerada pelas funções. Para que uma unidade de escala poderia consistir em x funções da web e trabalhador, filas de _y_ e _z_ contas de armazenamento. Crie o aplicativo para que ele está facilmente dimensionado adicionando uma ou mais unidades de escala.
- **Evite afinidade de cliente**. Sempre que possível, certifique-se de que o aplicativo não exige afinidade. Solicitações, portanto, poderão ser roteadas para qualquer instância e o número de instâncias é irrelevante. Isso também evita a sobrecarga de armazenar, recuperar e manter as informações de estado para cada usuário.
- **Tire proveito dos recursos de autoscaling de plataforma**. Onde a plataforma de hospedagem oferece suporte a um recurso de auto-dimensionamento, como escala automática do Azure, preferir-mecanismos personalizados ou de terceiros, a menos que o mecanismo interno não pode atender suas necessidades. Usar regras de dimensionamento agendadas onde possível para garantir que recursos estão disponíveis sem um atraso de inicialização, mas adicionar autoscaling reativo às regras onde apropriado para lidar com alterações inesperadas na demanda. Você pode usar as operações de autoscaling na API de gerenciamento do serviço para ajustar auto-dimensionamento e adicionar contadores personalizados para regras. Para obter mais informações, consulte [diretrizes de escala automática](best-practices-auto-scaling.md).
- **Descarregar intenso tarefas de CPU/IO como tarefas em segundo plano**. Se uma solicitação para um serviço é esperada para levar muito tempo para executar ou absorvê recursos consideráveis, descarregar o processamento para esta solicitação para uma tarefa separada. Usar funções de trabalho ou trabalhos de plano de fundo (dependendo da plataforma de hospedagem) para executar essas tarefas. Essa estratégia permite que o serviço continuar recebendo ainda mais solicitações e continuem respondendo.  Para obter mais informações, consulte [diretrizes de trabalhos de plano de fundo](best-practices-background-jobs.md).
- **Distribuir a carga de trabalho para tarefas em segundo plano**. Onde há muitas tarefas de plano de fundo ou as tarefas exigem um tempo considerável ou recursos, afaste o trabalho em várias unidades de computação (como funções de trabalho ou trabalhos em segundo plano). Para uma solução possível, consulte o [Que competem consumidores padrão](https://msdn.microsoft.com/library/dn568101.aspx).
- **Considere em direção um _nada compartilhado_ arquitetura**. Uma arquitetura de nada compartilhado usa independentes, auto-suficiente, nós que não possuem nenhum ponto de disputa (como serviços compartilhados ou armazenamento). Em teoria, esse sistema pode dimensionar quase indefinidamente. Enquanto uma abordagem nada totalmente compartilhadas geralmente não é prática para a maioria dos aplicativos, ele poderá fornecer oportunidades projetar para melhor escalabilidade. Por exemplo, evitar o uso de estado de sessão de servidor, afinidade do cliente e partição de dados são bons exemplos de transição para uma arquitetura de nada compartilhado.

## <a name="data-management"></a>Gerenciamento de dados

- **Usar dados partição**. Dividir os dados em vários bancos de dados e servidores de banco de dados ou design o aplicativo para usar o armazenamento de dados serviços que pode fornecer essa divisão transparente (exemplos elástica de banco de dados do Azure SQL Database e armazenamento de tabela do Azure). Essa abordagem pode ajudar a maximizar o desempenho e permitir dimensionamento mais fácil. Há diferentes partição técnicas, como horizontal, vertical e funcional. Você pode usar uma combinação para obter o benefício máximo de consulta aumento de desempenho, escalabilidade mais simples, gerenciamento mais flexível, melhor disponibilidade e para corresponder ao tipo de armazenamento para os dados que ela armazenará. Além disso, considere o uso de diferentes tipos de armazenamento de dados para diferentes tipos de dados, escolhendo os tipos com base em como eles são otimizados para o tipo específico de dados. Isso pode incluir usando o armazenamento de tabela, um banco de dados do documento ou um armazenamento de dados de coluna família, em vez de, ou bem como, um banco de dados relacional. Para obter mais informações, consulte [diretrizes de partição de dados](best-practices-data-partitioning.md).
- **Design de consistência eventual**. Consistência eventual melhora a escalabilidade reduzindo ou removendo o tempo necessário para sincronizar dados relacionados particionados em diversos armazenamentos. O custo é que dados nem sempre são consistentes quando ele é lido e alguns escrever operações podem causar conflitos. Consistência eventual é ideal para situações em que os mesmos dados é ler com frequência mas raramente gravados. Para obter mais informações, consulte a [Introdução de consistência de dados](https://msdn.microsoft.com/library/dn589800.aspx).
- **Reduzir informais interações entre serviços e componentes**. Evite estruturar interações em que um aplicativo é necessária para fazer várias chamadas para um serviço (cada um deles retorna uma pequena quantidade de dados), em vez de uma única chamada que pode retornar todos os dados. Sempre que possível, combine várias operações relacionadas em uma única solicitação quando a chamada é para um serviço ou componente que tem latência perceptível. Isso facilita a monitorar o desempenho e otimizar operações complexas. Por exemplo, usar procedimentos armazenados em bancos de dados para encapsular lógica complexa e reduzir o número de idas e o bloqueio de recurso.
- **Usar filas para nivelar a carga de gravação de dados de alta velocidade**. Aumentos na demanda para um serviço podem sobrecarregar desse serviço e causar falhas crescentes. Para evitar isso, considere a possibilidade de implementar o [padrão de redistribuição de carga baseado em fila](https://msdn.microsoft.com/library/dn589783.aspx). Use uma fila que atua como um buffer entre uma tarefa e um serviço que ele chama. Isso pode suaves intermitente sobrecarga que pode causar caso contrário, o serviço falha ou a tarefa tempo limite.
- **Minimizar a carga no repositório de dados**. O armazenamento de dados normalmente é um gargalo de processamento, um recurso caro e geralmente não fácil dimensionar check-out. Sempre que possível, remova lógica (como processamento documentos XML ou objetos JSON) do armazenamento de dados e executar o processamento dentro do aplicativo. Por exemplo, em vez de passando XML para o banco de dados (diferente de como uma cadeia de caracteres opaca para armazenamento), serializar ou desserializar o XML dentro da camada de aplicativo e passe em um formulário que é nativo ao armazenamento de dados. É geralmente muito mais fácil dimensionar o aplicativo que o armazenamento de dados, portanto você deve tentar fazer quanto do processamento pesados possível dentro do aplicativo.
- **Minimizar o volume de dados recuperados**. Recuperar somente os dados que exigem especificando colunas e o uso de critérios para selecionar linhas. Faça uso de parâmetros de valor de tabela e o nível de isolamento apropriado. Mecanismos de uso como marcas de entidade para evitar a recuperação de dados desnecessariamente.
- **Usar ativamente o cache**. Usar o cache sempre que possível para reduzir a carga sobre recursos e serviços que geram ou fornecem dados. Normalmente é adequado aos dados que são relativamente estático, ou que requer processamento considerável para obter armazenamento em cache. Armazenamento em cache deve ocorrer em todos os níveis onde apropriado em cada camada do aplicativo, incluindo geração de interface de acesso e o usuário de dados. Para obter mais informações, consulte a [Orientação de armazenamento em cache](best-practices-caching.md).
- **Lidar com o crescimento de dados e retenção**. Aumenta a quantidade de dados armazenados por um aplicativo ao longo do tempo. Esse crescimento aumenta os custos de armazenamento e aumenta a latência ao acessar os dados — que afetam o desempenho e taxa de transferência do aplicativo. Talvez seja possível periodicamente arquivar alguns dos dados antigos que já não são acessados ou mover dados raramente acessados para o armazenamento de longo prazo que é o custo mais eficiente, mesmo se a latência de acesso for maior.
- **Otimizar transferir objetos de dados (DTOs) usando um formato binário eficiente**. DTOs são passados entre as camadas de um aplicativo muitas vezes. Minimizar o tamanho reduz a carga sobre recursos e da rede. No entanto, saldo a economia com a sobrecarga de converter os dados para o formato obrigatório em cada local onde ele é usado. Adote um formato que tenha a interoperabilidade máxima para habilitar fácil reutilização de um componente.
- **Definir o controle de cache**. Projetar e configurar o aplicativo para usar o cache de saída, ou sempre que possível, para minimizar a carga de processamento de cache de fragmento.
- **Habilitar o cache do cliente**. Aplicativos da Web devem habilitar configurações de cache no conteúdo que podem ser armazenados em cache. Normalmente, isso é desabilitado por padrão. Configure o servidor para fornecer o cache apropriado cabeçalhos de controle para habilitar o cache de conteúdo em servidores proxy e clientes.
- **Armazenamento de blob do Azure de uso e a rede de entrega de conteúdo do Azure para reduzir a carga no aplicativo**. Considere a possibilidade de armazenar conteúdo público estático ou relativamente estático, como imagens, recursos, scripts e folhas de estilo, em armazenamento de blob. Essa abordagem libera o aplicativo da carga causado por Gerando dinamicamente esse conteúdo para cada solicitação. Além disso, considere o uso da rede de entrega de conteúdo para cache esse conteúdo e entregá-lo aos clientes. Usando a rede de entrega de conteúdo pode melhorar o desempenho no cliente porque o conteúdo seja entregue do data center geograficamente mais próximo que contém um cache de rede de distribuição de conteúdo. Para obter mais informações, consulte o [Guia de rede de distribuição de conteúdo](best-practices-cdn.md).
- **Otimizar e consultas SQL de ajuste e índices**. Algumas instruções T-SQL ou construções podem ter um impacto no desempenho que pode ser reduzido otimizando o código em um procedimento armazenado. Por exemplo, evite convertendo tipos de **datetime** em um **varchar** antes comparado com um valor de literal de **datetime** . Use funções de comparação de data/hora. Falta de índices apropriados também pode reduzir a execução da consulta. Se você usar uma estrutura de mapeamento de objeto/relacional, entenda como ele funciona e como ele pode afetar o desempenho da camada de acesso de dados. Para obter mais informações, consulte [Ajuste de consulta](https://technet.microsoft.com/library/ms176005.aspx).
- **Considere eliminação normalização dos dados**. Normalização de dados ajuda a evitar duplicação e inconsistência. No entanto, mantendo vários índices, verificação de integridade referencial, executar vários acessos a pequenos blocos de dados e associar tabelas para Monte os dados impõe uma sobrecarga que pode afetar o desempenho. Considere se alguns volume de armazenamento adicional e duplicação é aceitável para reduzir a carga no repositório de dados. Além disso, considere se o próprio aplicativo (que é geralmente mais fácil dimensionar) pode ser considerado assumir tarefas como gerenciar a integridade referencial para reduzir a carga no repositório de dados. Para obter mais informações, consulte [diretrizes de partição de dados](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## <a name="service-implementation"></a>Implementação de serviço
- **Chamadas assíncronas de uso**. Use código assíncrono sempre que possível quando ao acessar recursos ou serviços que podem ser limitados pela e/s ou a largura de banda de rede ou que têm uma latência perceptível, para evitar bloqueio thread de chamada. Para implementar operações assíncronas, use o [Padrão assíncrono baseado em tarefas (toque)](https://msdn.microsoft.com/library/hh873175.aspx).
- **Evitar o bloqueio de recursos e em vez disso, use uma abordagem otimista**. Nunca bloquear acesso aos recursos como armazenamento ou outros serviços que têm latência perceptível, pois essa é uma causa primária de mau desempenho. Sempre use abordagens otimistas Gerenciando operações simultâneas, como escrever ao armazenamento. Use recursos de camada de armazenamento para gerenciar os conflitos. Em aplicativos distribuídos, dados podem ser apenas eventualmente consistentes.
- **Compactar dados altamente compactados sobre alta latência, redes de baixa largura de banda**. Na maioria dos casos em um aplicativo web, o maior volume de dados gerados pelo aplicativo e passadas pela rede é respostas HTTP para solicitações de cliente. Compactação HTTP pode reduzir isso consideravelmente, especialmente para conteúdo estático. Isso pode reduzir custos, bem como reduzindo a carga na rede, embora compacta o conteúdo dinâmico aplica uma carga fractionally maior no servidor. Em outros, mais ambientes generalizadas, compactação de dados pode reduzir o volume dos dados transmitidos e minimizar o tempo de transferência e os custos, mas os processos de compactação e descompactação provocam sobrecarga. Assim, compactação só deve ser usada quando há um ganho demonstrável no desempenho. Outros métodos de serialização, como JSON ou codificações binárias, podem reduzir o tamanho de carga tendo menos impacto sobre o desempenho, enquanto o XML é provável para aumentá-la.
- **Minimizar o tempo que conexões e recursos estão em uso**. Manter conexões e recursos somente para desde que você precisa usá-los. Por exemplo, abra conexões mais tarde possível e permitir que ele seja retornado para o pool de conexão assim que possível. Adquirir recursos mais tarde possível e descartá-los assim que possível.
- **Minimize o número de conexões necessárias**. Conexões de serviço absorvê recursos. Limite o número que são necessários e certifique-se de que as conexões existentes são reutilizadas sempre que possível. Por exemplo, depois de executar autenticação, use representação onde apropriado para executar o código como uma identidade específica. Isso pode ajudar a fazer o melhor uso do pool de conexão reutilizando conexões.

    > [AZURE.NOTE]: APIs for some services automatically reuse connections, provided service-specific guidelines are followed. It's important that you understand the conditions that enable connection reuse for each service that your application uses.

- **Enviar solicitações em lotes para otimizar o uso de rede**. Por exemplo, enviar e ler mensagens em lotes ao acessar uma fila e realizar várias leituras ou gravações como um lote ao acessar o armazenamento ou um cache. Isso pode ajudar a maximizar a eficiência dos armazenamentos de dados e os serviços, reduzindo o número de chamadas através da rede.
- **Evite um requisito para armazenar o estado de sessão de servidor** sempre que possível. Gerenciamento de estado de sessão de servidor normalmente requer afinidade do cliente (isto é, roteamento de cada solicitação para a mesma instância do servidor), que afeta a capacidade do sistema de dimensionar. Ideal, você deve projetar clientes sem estado relacionadas com os servidores que usarem. No entanto, se o aplicativo deve manter o estado de sessão, armazene dados confidenciais ou grandes volumes de dados de cada cliente em um cache distribuído do lado do servidor que podem acessar todas as instâncias do aplicativo.
- **Otimizar esquemas de armazenamento de tabela**. Ao usar armazenamentos de tabela que exigem os nomes de coluna e tabela será passado e processado com cada consulta, como o armazenamento de tabela do Microsoft Azure, considere usar nomes menores para reduzir essa sobrecarga. No entanto, sem interferir legibilidade ou gerenciamento usando nomes muito compactos.
- **Use a tarefa paralela TPL (biblioteca) para realizar operações assíncronas**. A TPL torna mais fácil de escrever código assíncrono que efetua operações vinculada a e/S. Use _ConfigureAwait (False)_ sempre que possível para eliminar a dependência de uma continuação em um contexto de sincronização específico. Isso reduz as chances de bloqueio de segmento ocorrendo.
- **Criar dependências de recurso durante a implantação ou na inicialização do aplicativo**. Evite chamadas repetidas para métodos que testar a existência de um recurso e, em seguida, criar o recurso se ele não existir. (Métodos como _CloudTable.CreateIfNotExists_ e _CloudQueue.CreateIfNotExists_ na biblioteca de cliente de armazenamento do Azure siga esse padrão). Esses métodos podem impor uma sobrecarga considerável se eles são chamados antes de cada acesso a uma tabela de armazenamento ou fila do armazenamento. Em vez disso:
 - Criar os recursos necessários quando o aplicativo é implantado, ou quando ele é iniciado (uma única chamada para _CreateIfNotExists_ para cada recurso no código de inicialização para uma função da web ou de trabalho é aceitável). No entanto, certifique-se de manipular exceções que podem surgir se seu código tentar acessar um recurso que não existe. Nesses casos, você deve fazer a exceção e possivelmente alertar um operador que um recurso está ausente.
 - Em algumas circunstâncias, pode ser apropriado para criar o recurso ausente como parte da código de manipulação de exceção. Mas você deve adotar essa abordagem com cuidado como a não-existência do recurso pode ser indicativa de um erro de programação (um nome de recurso incorreta por exemplo) ou algum outro problema de nível de infraestrutura.
- **Estruturas de leve de uso**. Escolha cuidadosamente as APIs e estruturas que você usa para minimizar o uso do recurso, tempo de execução e carga total no aplicativo. Por exemplo, usando a API da Web para lidar com solicitações de serviço pode reduzir o espaço de aplicativo e aumentar a velocidade de execução, mas talvez não seja adequado para cenários avançados, onde os recursos adicionais do Windows Communication Foundation são necessários.
- **Considere minimizando o número de contas de serviço**. Por exemplo, use uma conta específica para acessar recursos ou serviços que impõem um limite em conexões ou realizar melhor onde menos conexões são mantidos. Essa abordagem é comum para serviços como bancos de dados, mas ele pode afetar a capacidade de auditoria com precisão das operações devido a representação do usuário original.
- **Executadas perfil de desempenho e testes de carga** durante o desenvolvimento, como parte das rotinas de teste e antes da versão final para garantir que o aplicativo executa e escalas conforme necessário. Esse teste deve ocorrer no mesmo tipo de hardware como a plataforma de produção e com os mesmos tipos e quantidades de dados e o usuário carregar como ele encontrarão em produção. Para obter mais informações, consulte [testes de desempenho de um serviço de nuvem](vs-azure-tools-performance-profiling-cloud-services.md).
